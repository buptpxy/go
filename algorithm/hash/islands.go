/*
【岛问题】
一个矩阵中只有0和1两种值， 每个位置都可以和自己的上、 下、 左、 右四个位置相连，
如果有一片1连在一起， 这个部分叫做一个岛， 求一个矩阵中有多少个岛？
举例：
	0 0 1 0 1 0
	1 1 1 0 1 0
	1 0 0 1 0 0
	0 0 0 0 0 0
	这个矩阵中有三个岛。
【思路】如果是大矩阵，则可以把它分成多个小矩阵，求每个小矩阵里面有多少个岛，
		即一个集合里面有多少个元素，再利用并查集把所有集合都合并起来。
		只需考虑相邻矩阵的边界上的点是否为1，为1则可合并为一个岛。
		如果为一个矩阵，则可以使用感染函数，即若发现一个数为1，则把其变为2，并把其上下左右为1的数都变为2并递归调用，这群2就是一个岛。
		然后遍历这个矩阵，求出岛的数目。
*/
package main

import (
	"fmt"
)

func infect(m [][]int, i int, j int) {
	//递归函数不需要for循环，但是一定要有终止条件，终止条件可以什么都不返回
	row := len(m)
	col := len(m[0])
	if i < 0 || i >= row || j < 0 || j >= col || m[i][j] != 1 {
		return
	}
	m[i][j] = 2
	infect(m, i+1, j)
	infect(m, i-1, j)
	infect(m, i, j+1)
	infect(m, i, j-1)
}

func islands(m [][]int) int {
	if len(m) == 0 || len(m[0]) == 0 {
		return 0
	}
	num := 0
	row := len(m)
	col := len(m[0])
	for i := 0; i < row; i++ {
		for j := 0; j < col; j++ {
			if m[i][j] == 1 {
				num++
				infect(m, i, j)
			}
		}
	}
	return num
}

func main() {
	m := [][]int{
		{1, 0, 0, 0, 0, 0, 0, 0, 0},
		{0, 1, 1, 1, 1, 0, 1, 1, 1},
		{0, 1, 1, 1, 0, 0, 0, 1, 0},
		{0, 1, 1, 0, 0, 0, 0, 0, 0},
		{0, 0, 0, 0, 0, 1, 1, 0, 0},
		{0, 0, 0, 0, 1, 1, 1, 0, 0},
		{0, 0, 0, 0, 0, 0, 0, 0, 0},
	}
	// infect(m, 1, 1)
	// for i := 0; i < len(m); i++ {
	// 	fmt.Println(m[i])
	// }
	fmt.Println(islands(m))
	m1 := [][]int{}
	fmt.Println(islands(m1))
}
